// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/pb_msg/ai_animation.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fpb_5fmsg_2fai_5fanimation_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2fpb_5fmsg_2fai_5fanimation_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "common/pb_msg/common.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2fpb_5fmsg_2fai_5fanimation_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
namespace pb_msg {
class AiAnimation;
struct AiAnimationDefaultTypeInternal;
extern AiAnimationDefaultTypeInternal _AiAnimation_default_instance_;
class AiMeshAnim;
struct AiMeshAnimDefaultTypeInternal;
extern AiMeshAnimDefaultTypeInternal _AiMeshAnim_default_instance_;
class AiMeshKey;
struct AiMeshKeyDefaultTypeInternal;
extern AiMeshKeyDefaultTypeInternal _AiMeshKey_default_instance_;
class AiMeshMorphAnim;
struct AiMeshMorphAnimDefaultTypeInternal;
extern AiMeshMorphAnimDefaultTypeInternal _AiMeshMorphAnim_default_instance_;
class AiMeshMorphKey;
struct AiMeshMorphKeyDefaultTypeInternal;
extern AiMeshMorphKeyDefaultTypeInternal _AiMeshMorphKey_default_instance_;
class AiNodeAnim;
struct AiNodeAnimDefaultTypeInternal;
extern AiNodeAnimDefaultTypeInternal _AiNodeAnim_default_instance_;
class AiQuatKey;
struct AiQuatKeyDefaultTypeInternal;
extern AiQuatKeyDefaultTypeInternal _AiQuatKey_default_instance_;
class AiVectorKey;
struct AiVectorKeyDefaultTypeInternal;
extern AiVectorKeyDefaultTypeInternal _AiVectorKey_default_instance_;
}  // namespace pb_msg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace pb_msg {

// ===================================================================


// -------------------------------------------------------------------

class AiAnimation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiAnimation) */ {
 public:
  inline AiAnimation() : AiAnimation(nullptr) {}
  ~AiAnimation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiAnimation(::google::protobuf::internal::ConstantInitialized);

  AiAnimation(const AiAnimation& from);
  AiAnimation(AiAnimation&& from) noexcept
    : AiAnimation() {
    *this = ::std::move(from);
  }

  inline AiAnimation& operator=(const AiAnimation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiAnimation& operator=(AiAnimation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiAnimation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiAnimation* internal_default_instance() {
    return reinterpret_cast<const AiAnimation*>(
               &_AiAnimation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AiAnimation& a, AiAnimation& b) {
    a.Swap(&b);
  }
  inline void Swap(AiAnimation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiAnimation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiAnimation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiAnimation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiAnimation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiAnimation& from) {
    AiAnimation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiAnimation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiAnimation";
  }
  protected:
  explicit AiAnimation(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 4,
    kMeshChannelsFieldNumber = 5,
    kMorphMeshChannelsFieldNumber = 6,
    kNameFieldNumber = 1,
    kDurationFieldNumber = 2,
    kTicksPerSecondFieldNumber = 3,
  };
  // repeated .pb_msg.AiNodeAnim Channels = 4;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::pb_msg::AiNodeAnim* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiNodeAnim >*
      mutable_channels();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiNodeAnim>& _internal_channels() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiNodeAnim>* _internal_mutable_channels();
  public:
  const ::pb_msg::AiNodeAnim& channels(int index) const;
  ::pb_msg::AiNodeAnim* add_channels();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiNodeAnim >&
      channels() const;
  // repeated .pb_msg.AiMeshAnim MeshChannels = 5;
  int meshchannels_size() const;
  private:
  int _internal_meshchannels_size() const;

  public:
  void clear_meshchannels() ;
  ::pb_msg::AiMeshAnim* mutable_meshchannels(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshAnim >*
      mutable_meshchannels();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshAnim>& _internal_meshchannels() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshAnim>* _internal_mutable_meshchannels();
  public:
  const ::pb_msg::AiMeshAnim& meshchannels(int index) const;
  ::pb_msg::AiMeshAnim* add_meshchannels();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshAnim >&
      meshchannels() const;
  // repeated .pb_msg.AiMeshMorphAnim MorphMeshChannels = 6;
  int morphmeshchannels_size() const;
  private:
  int _internal_morphmeshchannels_size() const;

  public:
  void clear_morphmeshchannels() ;
  ::pb_msg::AiMeshMorphAnim* mutable_morphmeshchannels(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphAnim >*
      mutable_morphmeshchannels();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphAnim>& _internal_morphmeshchannels() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphAnim>* _internal_mutable_morphmeshchannels();
  public:
  const ::pb_msg::AiMeshMorphAnim& morphmeshchannels(int index) const;
  ::pb_msg::AiMeshMorphAnim* add_morphmeshchannels();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphAnim >&
      morphmeshchannels() const;
  // string Name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // double Duration = 2;
  void clear_duration() ;
  double duration() const;
  void set_duration(double value);

  private:
  double _internal_duration() const;
  void _internal_set_duration(double value);

  public:
  // double TicksPerSecond = 3;
  void clear_tickspersecond() ;
  double tickspersecond() const;
  void set_tickspersecond(double value);

  private:
  double _internal_tickspersecond() const;
  void _internal_set_tickspersecond(double value);

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiAnimation)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 3, 31, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiNodeAnim > channels_;
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshAnim > meshchannels_;
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphAnim > morphmeshchannels_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    double duration_;
    double tickspersecond_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};// -------------------------------------------------------------------

class AiMeshMorphAnim final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiMeshMorphAnim) */ {
 public:
  inline AiMeshMorphAnim() : AiMeshMorphAnim(nullptr) {}
  ~AiMeshMorphAnim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiMeshMorphAnim(::google::protobuf::internal::ConstantInitialized);

  AiMeshMorphAnim(const AiMeshMorphAnim& from);
  AiMeshMorphAnim(AiMeshMorphAnim&& from) noexcept
    : AiMeshMorphAnim() {
    *this = ::std::move(from);
  }

  inline AiMeshMorphAnim& operator=(const AiMeshMorphAnim& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiMeshMorphAnim& operator=(AiMeshMorphAnim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiMeshMorphAnim& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiMeshMorphAnim* internal_default_instance() {
    return reinterpret_cast<const AiMeshMorphAnim*>(
               &_AiMeshMorphAnim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AiMeshMorphAnim& a, AiMeshMorphAnim& b) {
    a.Swap(&b);
  }
  inline void Swap(AiMeshMorphAnim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiMeshMorphAnim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiMeshMorphAnim* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiMeshMorphAnim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiMeshMorphAnim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiMeshMorphAnim& from) {
    AiMeshMorphAnim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiMeshMorphAnim* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiMeshMorphAnim";
  }
  protected:
  explicit AiMeshMorphAnim(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .pb_msg.AiMeshMorphKey Keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  ::pb_msg::AiMeshMorphKey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphKey >*
      mutable_keys();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphKey>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphKey>* _internal_mutable_keys();
  public:
  const ::pb_msg::AiMeshMorphKey& keys(int index) const;
  ::pb_msg::AiMeshMorphKey* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphKey >&
      keys() const;
  // string Name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiMeshMorphAnim)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 35, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphKey > keys_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};// -------------------------------------------------------------------

class AiMeshMorphKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiMeshMorphKey) */ {
 public:
  inline AiMeshMorphKey() : AiMeshMorphKey(nullptr) {}
  ~AiMeshMorphKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiMeshMorphKey(::google::protobuf::internal::ConstantInitialized);

  AiMeshMorphKey(const AiMeshMorphKey& from);
  AiMeshMorphKey(AiMeshMorphKey&& from) noexcept
    : AiMeshMorphKey() {
    *this = ::std::move(from);
  }

  inline AiMeshMorphKey& operator=(const AiMeshMorphKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiMeshMorphKey& operator=(AiMeshMorphKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiMeshMorphKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiMeshMorphKey* internal_default_instance() {
    return reinterpret_cast<const AiMeshMorphKey*>(
               &_AiMeshMorphKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AiMeshMorphKey& a, AiMeshMorphKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AiMeshMorphKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiMeshMorphKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiMeshMorphKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiMeshMorphKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiMeshMorphKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiMeshMorphKey& from) {
    AiMeshMorphKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiMeshMorphKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiMeshMorphKey";
  }
  protected:
  explicit AiMeshMorphKey(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kWeightsFieldNumber = 3,
    kTimeFieldNumber = 1,
  };
  // repeated uint32 Values = 2;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  ::uint32_t values(int index) const;
  void set_values(int index, ::uint32_t value);
  void add_values(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_values() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_values();

  public:
  // repeated double Weights = 3;
  int weights_size() const;
  private:
  int _internal_weights_size() const;

  public:
  void clear_weights() ;
  double weights(int index) const;
  void set_weights(int index, double value);
  void add_weights(double value);
  const ::google::protobuf::RepeatedField<double>& weights() const;
  ::google::protobuf::RepeatedField<double>* mutable_weights();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_weights() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_weights();

  public:
  // double Time = 1;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiMeshMorphKey)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedField<::uint32_t> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    ::google::protobuf::RepeatedField<double> weights_;
    double time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};// -------------------------------------------------------------------

class AiNodeAnim final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiNodeAnim) */ {
 public:
  inline AiNodeAnim() : AiNodeAnim(nullptr) {}
  ~AiNodeAnim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiNodeAnim(::google::protobuf::internal::ConstantInitialized);

  AiNodeAnim(const AiNodeAnim& from);
  AiNodeAnim(AiNodeAnim&& from) noexcept
    : AiNodeAnim() {
    *this = ::std::move(from);
  }

  inline AiNodeAnim& operator=(const AiNodeAnim& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiNodeAnim& operator=(AiNodeAnim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiNodeAnim& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiNodeAnim* internal_default_instance() {
    return reinterpret_cast<const AiNodeAnim*>(
               &_AiNodeAnim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AiNodeAnim& a, AiNodeAnim& b) {
    a.Swap(&b);
  }
  inline void Swap(AiNodeAnim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiNodeAnim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiNodeAnim* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiNodeAnim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiNodeAnim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiNodeAnim& from) {
    AiNodeAnim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiNodeAnim* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiNodeAnim";
  }
  protected:
  explicit AiNodeAnim(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionKeysFieldNumber = 2,
    kRotationKeysFieldNumber = 3,
    kScalingKeysFieldNumber = 4,
    kNodeNameFieldNumber = 1,
    kPreStateFieldNumber = 5,
    kPostStateFieldNumber = 6,
  };
  // repeated .pb_msg.AiVectorKey PositionKeys = 2;
  int positionkeys_size() const;
  private:
  int _internal_positionkeys_size() const;

  public:
  void clear_positionkeys() ;
  ::pb_msg::AiVectorKey* mutable_positionkeys(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >*
      mutable_positionkeys();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>& _internal_positionkeys() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>* _internal_mutable_positionkeys();
  public:
  const ::pb_msg::AiVectorKey& positionkeys(int index) const;
  ::pb_msg::AiVectorKey* add_positionkeys();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >&
      positionkeys() const;
  // repeated .pb_msg.AiQuatKey RotationKeys = 3;
  int rotationkeys_size() const;
  private:
  int _internal_rotationkeys_size() const;

  public:
  void clear_rotationkeys() ;
  ::pb_msg::AiQuatKey* mutable_rotationkeys(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiQuatKey >*
      mutable_rotationkeys();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiQuatKey>& _internal_rotationkeys() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiQuatKey>* _internal_mutable_rotationkeys();
  public:
  const ::pb_msg::AiQuatKey& rotationkeys(int index) const;
  ::pb_msg::AiQuatKey* add_rotationkeys();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiQuatKey >&
      rotationkeys() const;
  // repeated .pb_msg.AiVectorKey ScalingKeys = 4;
  int scalingkeys_size() const;
  private:
  int _internal_scalingkeys_size() const;

  public:
  void clear_scalingkeys() ;
  ::pb_msg::AiVectorKey* mutable_scalingkeys(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >*
      mutable_scalingkeys();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>& _internal_scalingkeys() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>* _internal_mutable_scalingkeys();
  public:
  const ::pb_msg::AiVectorKey& scalingkeys(int index) const;
  ::pb_msg::AiVectorKey* add_scalingkeys();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >&
      scalingkeys() const;
  // string NodeName = 1;
  void clear_nodename() ;
  const std::string& nodename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nodename(Arg_&& arg, Args_... args);
  std::string* mutable_nodename();
  PROTOBUF_NODISCARD std::string* release_nodename();
  void set_allocated_nodename(std::string* ptr);

  private:
  const std::string& _internal_nodename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nodename(
      const std::string& value);
  std::string* _internal_mutable_nodename();

  public:
  // int32 PreState = 5;
  void clear_prestate() ;
  ::int32_t prestate() const;
  void set_prestate(::int32_t value);

  private:
  ::int32_t _internal_prestate() const;
  void _internal_set_prestate(::int32_t value);

  public:
  // int32 PostState = 6;
  void clear_poststate() ;
  ::int32_t poststate() const;
  void set_poststate(::int32_t value);

  private:
  ::int32_t _internal_poststate() const;
  void _internal_set_poststate(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiNodeAnim)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 6, 3, 34, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey > positionkeys_;
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiQuatKey > rotationkeys_;
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey > scalingkeys_;
    ::google::protobuf::internal::ArenaStringPtr nodename_;
    ::int32_t prestate_;
    ::int32_t poststate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};// -------------------------------------------------------------------

class AiMeshAnim final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiMeshAnim) */ {
 public:
  inline AiMeshAnim() : AiMeshAnim(nullptr) {}
  ~AiMeshAnim() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiMeshAnim(::google::protobuf::internal::ConstantInitialized);

  AiMeshAnim(const AiMeshAnim& from);
  AiMeshAnim(AiMeshAnim&& from) noexcept
    : AiMeshAnim() {
    *this = ::std::move(from);
  }

  inline AiMeshAnim& operator=(const AiMeshAnim& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiMeshAnim& operator=(AiMeshAnim&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiMeshAnim& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiMeshAnim* internal_default_instance() {
    return reinterpret_cast<const AiMeshAnim*>(
               &_AiMeshAnim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AiMeshAnim& a, AiMeshAnim& b) {
    a.Swap(&b);
  }
  inline void Swap(AiMeshAnim* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiMeshAnim* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiMeshAnim* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiMeshAnim>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiMeshAnim& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiMeshAnim& from) {
    AiMeshAnim::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiMeshAnim* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiMeshAnim";
  }
  protected:
  explicit AiMeshAnim(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .pb_msg.AiMeshKey Keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;

  public:
  void clear_keys() ;
  ::pb_msg::AiMeshKey* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshKey >*
      mutable_keys();
  private:
  const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshKey>& _internal_keys() const;
  ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshKey>* _internal_mutable_keys();
  public:
  const ::pb_msg::AiMeshKey& keys(int index) const;
  ::pb_msg::AiMeshKey* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshKey >&
      keys() const;
  // string Name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiMeshAnim)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 30, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshKey > keys_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};// -------------------------------------------------------------------

class AiVectorKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiVectorKey) */ {
 public:
  inline AiVectorKey() : AiVectorKey(nullptr) {}
  ~AiVectorKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiVectorKey(::google::protobuf::internal::ConstantInitialized);

  AiVectorKey(const AiVectorKey& from);
  AiVectorKey(AiVectorKey&& from) noexcept
    : AiVectorKey() {
    *this = ::std::move(from);
  }

  inline AiVectorKey& operator=(const AiVectorKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiVectorKey& operator=(AiVectorKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiVectorKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiVectorKey* internal_default_instance() {
    return reinterpret_cast<const AiVectorKey*>(
               &_AiVectorKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AiVectorKey& a, AiVectorKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AiVectorKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiVectorKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiVectorKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiVectorKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiVectorKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiVectorKey& from) {
    AiVectorKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiVectorKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiVectorKey";
  }
  protected:
  explicit AiVectorKey(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTimeFieldNumber = 1,
  };
  // .pb_msg.AiVector3D Value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::pb_msg::AiVector3D& value() const;
  PROTOBUF_NODISCARD ::pb_msg::AiVector3D* release_value();
  ::pb_msg::AiVector3D* mutable_value();
  void set_allocated_value(::pb_msg::AiVector3D* value);
  void unsafe_arena_set_allocated_value(::pb_msg::AiVector3D* value);
  ::pb_msg::AiVector3D* unsafe_arena_release_value();

  private:
  const ::pb_msg::AiVector3D& _internal_value() const;
  ::pb_msg::AiVector3D* _internal_mutable_value();

  public:
  // double Time = 1;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiVectorKey)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pb_msg::AiVector3D* value_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};// -------------------------------------------------------------------

class AiQuatKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiQuatKey) */ {
 public:
  inline AiQuatKey() : AiQuatKey(nullptr) {}
  ~AiQuatKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiQuatKey(::google::protobuf::internal::ConstantInitialized);

  AiQuatKey(const AiQuatKey& from);
  AiQuatKey(AiQuatKey&& from) noexcept
    : AiQuatKey() {
    *this = ::std::move(from);
  }

  inline AiQuatKey& operator=(const AiQuatKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiQuatKey& operator=(AiQuatKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiQuatKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiQuatKey* internal_default_instance() {
    return reinterpret_cast<const AiQuatKey*>(
               &_AiQuatKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AiQuatKey& a, AiQuatKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AiQuatKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiQuatKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiQuatKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiQuatKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiQuatKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiQuatKey& from) {
    AiQuatKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiQuatKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiQuatKey";
  }
  protected:
  explicit AiQuatKey(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTimeFieldNumber = 1,
  };
  // .pb_msg.AiQuaternion Value = 2;
  bool has_value() const;
  void clear_value() ;
  const ::pb_msg::AiQuaternion& value() const;
  PROTOBUF_NODISCARD ::pb_msg::AiQuaternion* release_value();
  ::pb_msg::AiQuaternion* mutable_value();
  void set_allocated_value(::pb_msg::AiQuaternion* value);
  void unsafe_arena_set_allocated_value(::pb_msg::AiQuaternion* value);
  ::pb_msg::AiQuaternion* unsafe_arena_release_value();

  private:
  const ::pb_msg::AiQuaternion& _internal_value() const;
  ::pb_msg::AiQuaternion* _internal_mutable_value();

  public:
  // double Time = 1;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiQuatKey)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::pb_msg::AiQuaternion* value_;
    double time_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};// -------------------------------------------------------------------

class AiMeshKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb_msg.AiMeshKey) */ {
 public:
  inline AiMeshKey() : AiMeshKey(nullptr) {}
  ~AiMeshKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AiMeshKey(::google::protobuf::internal::ConstantInitialized);

  AiMeshKey(const AiMeshKey& from);
  AiMeshKey(AiMeshKey&& from) noexcept
    : AiMeshKey() {
    *this = ::std::move(from);
  }

  inline AiMeshKey& operator=(const AiMeshKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AiMeshKey& operator=(AiMeshKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AiMeshKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AiMeshKey* internal_default_instance() {
    return reinterpret_cast<const AiMeshKey*>(
               &_AiMeshKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AiMeshKey& a, AiMeshKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AiMeshKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AiMeshKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AiMeshKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AiMeshKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AiMeshKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AiMeshKey& from) {
    AiMeshKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AiMeshKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "pb_msg.AiMeshKey";
  }
  protected:
  explicit AiMeshKey(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // double Time = 1;
  void clear_time() ;
  double time() const;
  void set_time(double value);

  private:
  double _internal_time() const;
  void _internal_set_time(double value);

  public:
  // uint32 Value = 2;
  void clear_value() ;
  ::uint32_t value() const;
  void set_value(::uint32_t value);

  private:
  ::uint32_t _internal_value() const;
  void _internal_set_value(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:pb_msg.AiMeshKey)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double time_;
    ::uint32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fpb_5fmsg_2fai_5fanimation_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AiAnimation

// string Name = 1;
inline void AiAnimation::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AiAnimation::name() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiAnimation.Name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiAnimation::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb_msg.AiAnimation.Name)
}
inline std::string* AiAnimation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb_msg.AiAnimation.Name)
  return _s;
}
inline const std::string& AiAnimation::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AiAnimation::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiAnimation::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiAnimation::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pb_msg.AiAnimation.Name)
  return _impl_.name_.Release();
}
inline void AiAnimation::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb_msg.AiAnimation.Name)
}

// double Duration = 2;
inline void AiAnimation::clear_duration() {
  _impl_.duration_ = 0;
}
inline double AiAnimation::duration() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiAnimation.Duration)
  return _internal_duration();
}
inline void AiAnimation::set_duration(double value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiAnimation.Duration)
}
inline double AiAnimation::_internal_duration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.duration_;
}
inline void AiAnimation::_internal_set_duration(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.duration_ = value;
}

// double TicksPerSecond = 3;
inline void AiAnimation::clear_tickspersecond() {
  _impl_.tickspersecond_ = 0;
}
inline double AiAnimation::tickspersecond() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiAnimation.TicksPerSecond)
  return _internal_tickspersecond();
}
inline void AiAnimation::set_tickspersecond(double value) {
  _internal_set_tickspersecond(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiAnimation.TicksPerSecond)
}
inline double AiAnimation::_internal_tickspersecond() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tickspersecond_;
}
inline void AiAnimation::_internal_set_tickspersecond(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tickspersecond_ = value;
}

// repeated .pb_msg.AiNodeAnim Channels = 4;
inline int AiAnimation::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int AiAnimation::channels_size() const {
  return _internal_channels_size();
}
inline void AiAnimation::clear_channels() {
  _internal_mutable_channels()->Clear();
}
inline ::pb_msg::AiNodeAnim* AiAnimation::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiAnimation.Channels)
  return _internal_mutable_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiNodeAnim >*
AiAnimation::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiAnimation.Channels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_channels();
}
inline const ::pb_msg::AiNodeAnim& AiAnimation::channels(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiAnimation.Channels)
    return _internal_channels().Get(index);
}
inline ::pb_msg::AiNodeAnim* AiAnimation::add_channels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiNodeAnim* _add = _internal_mutable_channels()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiAnimation.Channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiNodeAnim >&
AiAnimation::channels() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiAnimation.Channels)
  return _internal_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiNodeAnim>&
AiAnimation::_internal_channels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiNodeAnim>*
AiAnimation::_internal_mutable_channels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.channels_;
}

// repeated .pb_msg.AiMeshAnim MeshChannels = 5;
inline int AiAnimation::_internal_meshchannels_size() const {
  return _internal_meshchannels().size();
}
inline int AiAnimation::meshchannels_size() const {
  return _internal_meshchannels_size();
}
inline void AiAnimation::clear_meshchannels() {
  _internal_mutable_meshchannels()->Clear();
}
inline ::pb_msg::AiMeshAnim* AiAnimation::mutable_meshchannels(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiAnimation.MeshChannels)
  return _internal_mutable_meshchannels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshAnim >*
AiAnimation::mutable_meshchannels() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiAnimation.MeshChannels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_meshchannels();
}
inline const ::pb_msg::AiMeshAnim& AiAnimation::meshchannels(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiAnimation.MeshChannels)
    return _internal_meshchannels().Get(index);
}
inline ::pb_msg::AiMeshAnim* AiAnimation::add_meshchannels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiMeshAnim* _add = _internal_mutable_meshchannels()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiAnimation.MeshChannels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshAnim >&
AiAnimation::meshchannels() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiAnimation.MeshChannels)
  return _internal_meshchannels();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshAnim>&
AiAnimation::_internal_meshchannels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.meshchannels_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshAnim>*
AiAnimation::_internal_mutable_meshchannels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.meshchannels_;
}

// repeated .pb_msg.AiMeshMorphAnim MorphMeshChannels = 6;
inline int AiAnimation::_internal_morphmeshchannels_size() const {
  return _internal_morphmeshchannels().size();
}
inline int AiAnimation::morphmeshchannels_size() const {
  return _internal_morphmeshchannels_size();
}
inline void AiAnimation::clear_morphmeshchannels() {
  _internal_mutable_morphmeshchannels()->Clear();
}
inline ::pb_msg::AiMeshMorphAnim* AiAnimation::mutable_morphmeshchannels(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiAnimation.MorphMeshChannels)
  return _internal_mutable_morphmeshchannels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphAnim >*
AiAnimation::mutable_morphmeshchannels() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiAnimation.MorphMeshChannels)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_morphmeshchannels();
}
inline const ::pb_msg::AiMeshMorphAnim& AiAnimation::morphmeshchannels(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiAnimation.MorphMeshChannels)
    return _internal_morphmeshchannels().Get(index);
}
inline ::pb_msg::AiMeshMorphAnim* AiAnimation::add_morphmeshchannels() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiMeshMorphAnim* _add = _internal_mutable_morphmeshchannels()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiAnimation.MorphMeshChannels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphAnim >&
AiAnimation::morphmeshchannels() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiAnimation.MorphMeshChannels)
  return _internal_morphmeshchannels();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphAnim>&
AiAnimation::_internal_morphmeshchannels() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.morphmeshchannels_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphAnim>*
AiAnimation::_internal_mutable_morphmeshchannels() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.morphmeshchannels_;
}

// -------------------------------------------------------------------

// AiMeshMorphAnim

// string Name = 1;
inline void AiMeshMorphAnim::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AiMeshMorphAnim::name() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshMorphAnim.Name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiMeshMorphAnim::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb_msg.AiMeshMorphAnim.Name)
}
inline std::string* AiMeshMorphAnim::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb_msg.AiMeshMorphAnim.Name)
  return _s;
}
inline const std::string& AiMeshMorphAnim::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AiMeshMorphAnim::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiMeshMorphAnim::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiMeshMorphAnim::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pb_msg.AiMeshMorphAnim.Name)
  return _impl_.name_.Release();
}
inline void AiMeshMorphAnim::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb_msg.AiMeshMorphAnim.Name)
}

// repeated .pb_msg.AiMeshMorphKey Keys = 2;
inline int AiMeshMorphAnim::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int AiMeshMorphAnim::keys_size() const {
  return _internal_keys_size();
}
inline void AiMeshMorphAnim::clear_keys() {
  _internal_mutable_keys()->Clear();
}
inline ::pb_msg::AiMeshMorphKey* AiMeshMorphAnim::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiMeshMorphAnim.Keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphKey >*
AiMeshMorphAnim::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiMeshMorphAnim.Keys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_keys();
}
inline const ::pb_msg::AiMeshMorphKey& AiMeshMorphAnim::keys(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshMorphAnim.Keys)
    return _internal_keys().Get(index);
}
inline ::pb_msg::AiMeshMorphKey* AiMeshMorphAnim::add_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiMeshMorphKey* _add = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiMeshMorphAnim.Keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshMorphKey >&
AiMeshMorphAnim::keys() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiMeshMorphAnim.Keys)
  return _internal_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphKey>&
AiMeshMorphAnim::_internal_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshMorphKey>*
AiMeshMorphAnim::_internal_mutable_keys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// AiMeshMorphKey

// double Time = 1;
inline void AiMeshMorphKey::clear_time() {
  _impl_.time_ = 0;
}
inline double AiMeshMorphKey::time() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshMorphKey.Time)
  return _internal_time();
}
inline void AiMeshMorphKey::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiMeshMorphKey.Time)
}
inline double AiMeshMorphKey::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void AiMeshMorphKey::_internal_set_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// repeated uint32 Values = 2;
inline int AiMeshMorphKey::_internal_values_size() const {
  return _internal_values().size();
}
inline int AiMeshMorphKey::values_size() const {
  return _internal_values_size();
}
inline void AiMeshMorphKey::clear_values() {
  _internal_mutable_values()->Clear();
}
inline ::uint32_t AiMeshMorphKey::values(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshMorphKey.Values)
  return _internal_values().Get(index);
}
inline void AiMeshMorphKey::set_values(int index, ::uint32_t value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:pb_msg.AiMeshMorphKey.Values)
}
inline void AiMeshMorphKey::add_values(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:pb_msg.AiMeshMorphKey.Values)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& AiMeshMorphKey::values() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiMeshMorphKey.Values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* AiMeshMorphKey::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiMeshMorphKey.Values)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_values();
}

inline const ::google::protobuf::RepeatedField<::uint32_t>& AiMeshMorphKey::_internal_values() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* AiMeshMorphKey::_internal_mutable_values() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.values_;
}

// repeated double Weights = 3;
inline int AiMeshMorphKey::_internal_weights_size() const {
  return _internal_weights().size();
}
inline int AiMeshMorphKey::weights_size() const {
  return _internal_weights_size();
}
inline void AiMeshMorphKey::clear_weights() {
  _internal_mutable_weights()->Clear();
}
inline double AiMeshMorphKey::weights(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshMorphKey.Weights)
  return _internal_weights().Get(index);
}
inline void AiMeshMorphKey::set_weights(int index, double value) {
  _internal_mutable_weights()->Set(index, value);
  // @@protoc_insertion_point(field_set:pb_msg.AiMeshMorphKey.Weights)
}
inline void AiMeshMorphKey::add_weights(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_weights()->Add(value);
  // @@protoc_insertion_point(field_add:pb_msg.AiMeshMorphKey.Weights)
}
inline const ::google::protobuf::RepeatedField<double>& AiMeshMorphKey::weights() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiMeshMorphKey.Weights)
  return _internal_weights();
}
inline ::google::protobuf::RepeatedField<double>* AiMeshMorphKey::mutable_weights() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiMeshMorphKey.Weights)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_weights();
}

inline const ::google::protobuf::RepeatedField<double>& AiMeshMorphKey::_internal_weights() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weights_;
}
inline ::google::protobuf::RepeatedField<double>* AiMeshMorphKey::_internal_mutable_weights() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.weights_;
}

// -------------------------------------------------------------------

// AiNodeAnim

// string NodeName = 1;
inline void AiNodeAnim::clear_nodename() {
  _impl_.nodename_.ClearToEmpty();
}
inline const std::string& AiNodeAnim::nodename() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiNodeAnim.NodeName)
  return _internal_nodename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiNodeAnim::set_nodename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nodename_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb_msg.AiNodeAnim.NodeName)
}
inline std::string* AiNodeAnim::mutable_nodename() {
  std::string* _s = _internal_mutable_nodename();
  // @@protoc_insertion_point(field_mutable:pb_msg.AiNodeAnim.NodeName)
  return _s;
}
inline const std::string& AiNodeAnim::_internal_nodename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nodename_.Get();
}
inline void AiNodeAnim::_internal_set_nodename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nodename_.Set(value, GetArenaForAllocation());
}
inline std::string* AiNodeAnim::_internal_mutable_nodename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nodename_.Mutable( GetArenaForAllocation());
}
inline std::string* AiNodeAnim::release_nodename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pb_msg.AiNodeAnim.NodeName)
  return _impl_.nodename_.Release();
}
inline void AiNodeAnim::set_allocated_nodename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nodename_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nodename_.IsDefault()) {
          _impl_.nodename_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb_msg.AiNodeAnim.NodeName)
}

// repeated .pb_msg.AiVectorKey PositionKeys = 2;
inline int AiNodeAnim::_internal_positionkeys_size() const {
  return _internal_positionkeys().size();
}
inline int AiNodeAnim::positionkeys_size() const {
  return _internal_positionkeys_size();
}
inline void AiNodeAnim::clear_positionkeys() {
  _internal_mutable_positionkeys()->Clear();
}
inline ::pb_msg::AiVectorKey* AiNodeAnim::mutable_positionkeys(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiNodeAnim.PositionKeys)
  return _internal_mutable_positionkeys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >*
AiNodeAnim::mutable_positionkeys() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiNodeAnim.PositionKeys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_positionkeys();
}
inline const ::pb_msg::AiVectorKey& AiNodeAnim::positionkeys(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiNodeAnim.PositionKeys)
    return _internal_positionkeys().Get(index);
}
inline ::pb_msg::AiVectorKey* AiNodeAnim::add_positionkeys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiVectorKey* _add = _internal_mutable_positionkeys()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiNodeAnim.PositionKeys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >&
AiNodeAnim::positionkeys() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiNodeAnim.PositionKeys)
  return _internal_positionkeys();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>&
AiNodeAnim::_internal_positionkeys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.positionkeys_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>*
AiNodeAnim::_internal_mutable_positionkeys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.positionkeys_;
}

// repeated .pb_msg.AiQuatKey RotationKeys = 3;
inline int AiNodeAnim::_internal_rotationkeys_size() const {
  return _internal_rotationkeys().size();
}
inline int AiNodeAnim::rotationkeys_size() const {
  return _internal_rotationkeys_size();
}
inline void AiNodeAnim::clear_rotationkeys() {
  _internal_mutable_rotationkeys()->Clear();
}
inline ::pb_msg::AiQuatKey* AiNodeAnim::mutable_rotationkeys(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiNodeAnim.RotationKeys)
  return _internal_mutable_rotationkeys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiQuatKey >*
AiNodeAnim::mutable_rotationkeys() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiNodeAnim.RotationKeys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rotationkeys();
}
inline const ::pb_msg::AiQuatKey& AiNodeAnim::rotationkeys(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiNodeAnim.RotationKeys)
    return _internal_rotationkeys().Get(index);
}
inline ::pb_msg::AiQuatKey* AiNodeAnim::add_rotationkeys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiQuatKey* _add = _internal_mutable_rotationkeys()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiNodeAnim.RotationKeys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiQuatKey >&
AiNodeAnim::rotationkeys() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiNodeAnim.RotationKeys)
  return _internal_rotationkeys();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiQuatKey>&
AiNodeAnim::_internal_rotationkeys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rotationkeys_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiQuatKey>*
AiNodeAnim::_internal_mutable_rotationkeys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rotationkeys_;
}

// repeated .pb_msg.AiVectorKey ScalingKeys = 4;
inline int AiNodeAnim::_internal_scalingkeys_size() const {
  return _internal_scalingkeys().size();
}
inline int AiNodeAnim::scalingkeys_size() const {
  return _internal_scalingkeys_size();
}
inline void AiNodeAnim::clear_scalingkeys() {
  _internal_mutable_scalingkeys()->Clear();
}
inline ::pb_msg::AiVectorKey* AiNodeAnim::mutable_scalingkeys(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiNodeAnim.ScalingKeys)
  return _internal_mutable_scalingkeys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >*
AiNodeAnim::mutable_scalingkeys() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiNodeAnim.ScalingKeys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scalingkeys();
}
inline const ::pb_msg::AiVectorKey& AiNodeAnim::scalingkeys(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiNodeAnim.ScalingKeys)
    return _internal_scalingkeys().Get(index);
}
inline ::pb_msg::AiVectorKey* AiNodeAnim::add_scalingkeys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiVectorKey* _add = _internal_mutable_scalingkeys()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiNodeAnim.ScalingKeys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiVectorKey >&
AiNodeAnim::scalingkeys() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiNodeAnim.ScalingKeys)
  return _internal_scalingkeys();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>&
AiNodeAnim::_internal_scalingkeys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scalingkeys_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiVectorKey>*
AiNodeAnim::_internal_mutable_scalingkeys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scalingkeys_;
}

// int32 PreState = 5;
inline void AiNodeAnim::clear_prestate() {
  _impl_.prestate_ = 0;
}
inline ::int32_t AiNodeAnim::prestate() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiNodeAnim.PreState)
  return _internal_prestate();
}
inline void AiNodeAnim::set_prestate(::int32_t value) {
  _internal_set_prestate(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiNodeAnim.PreState)
}
inline ::int32_t AiNodeAnim::_internal_prestate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.prestate_;
}
inline void AiNodeAnim::_internal_set_prestate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.prestate_ = value;
}

// int32 PostState = 6;
inline void AiNodeAnim::clear_poststate() {
  _impl_.poststate_ = 0;
}
inline ::int32_t AiNodeAnim::poststate() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiNodeAnim.PostState)
  return _internal_poststate();
}
inline void AiNodeAnim::set_poststate(::int32_t value) {
  _internal_set_poststate(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiNodeAnim.PostState)
}
inline ::int32_t AiNodeAnim::_internal_poststate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.poststate_;
}
inline void AiNodeAnim::_internal_set_poststate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.poststate_ = value;
}

// -------------------------------------------------------------------

// AiMeshAnim

// string Name = 1;
inline void AiMeshAnim::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AiMeshAnim::name() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshAnim.Name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AiMeshAnim::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pb_msg.AiMeshAnim.Name)
}
inline std::string* AiMeshAnim::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pb_msg.AiMeshAnim.Name)
  return _s;
}
inline const std::string& AiMeshAnim::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AiMeshAnim::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AiMeshAnim::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* AiMeshAnim::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pb_msg.AiMeshAnim.Name)
  return _impl_.name_.Release();
}
inline void AiMeshAnim::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pb_msg.AiMeshAnim.Name)
}

// repeated .pb_msg.AiMeshKey Keys = 2;
inline int AiMeshAnim::_internal_keys_size() const {
  return _internal_keys().size();
}
inline int AiMeshAnim::keys_size() const {
  return _internal_keys_size();
}
inline void AiMeshAnim::clear_keys() {
  _internal_mutable_keys()->Clear();
}
inline ::pb_msg::AiMeshKey* AiMeshAnim::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:pb_msg.AiMeshAnim.Keys)
  return _internal_mutable_keys()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshKey >*
AiMeshAnim::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:pb_msg.AiMeshAnim.Keys)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_keys();
}
inline const ::pb_msg::AiMeshKey& AiMeshAnim::keys(int index) const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshAnim.Keys)
    return _internal_keys().Get(index);
}
inline ::pb_msg::AiMeshKey* AiMeshAnim::add_keys() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::pb_msg::AiMeshKey* _add = _internal_mutable_keys()->Add();
  // @@protoc_insertion_point(field_add:pb_msg.AiMeshAnim.Keys)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb_msg::AiMeshKey >&
AiMeshAnim::keys() const {
  // @@protoc_insertion_point(field_list:pb_msg.AiMeshAnim.Keys)
  return _internal_keys();
}
inline const ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshKey>&
AiMeshAnim::_internal_keys() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.keys_;
}
inline ::google::protobuf::RepeatedPtrField<::pb_msg::AiMeshKey>*
AiMeshAnim::_internal_mutable_keys() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.keys_;
}

// -------------------------------------------------------------------

// AiVectorKey

// double Time = 1;
inline void AiVectorKey::clear_time() {
  _impl_.time_ = 0;
}
inline double AiVectorKey::time() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiVectorKey.Time)
  return _internal_time();
}
inline void AiVectorKey::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiVectorKey.Time)
}
inline double AiVectorKey::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void AiVectorKey::_internal_set_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// .pb_msg.AiVector3D Value = 2;
inline bool AiVectorKey::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::pb_msg::AiVector3D& AiVectorKey::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pb_msg::AiVector3D* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb_msg::AiVector3D&>(::pb_msg::_AiVector3D_default_instance_);
}
inline const ::pb_msg::AiVector3D& AiVectorKey::value() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiVectorKey.Value)
  return _internal_value();
}
inline void AiVectorKey::unsafe_arena_set_allocated_value(::pb_msg::AiVector3D* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::pb_msg::AiVector3D*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb_msg.AiVectorKey.Value)
}
inline ::pb_msg::AiVector3D* AiVectorKey::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pb_msg::AiVector3D* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pb_msg::AiVector3D* AiVectorKey::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pb_msg.AiVectorKey.Value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pb_msg::AiVector3D* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::pb_msg::AiVector3D* AiVectorKey::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb_msg::AiVector3D>(GetArenaForAllocation());
    _impl_.value_ = reinterpret_cast<::pb_msg::AiVector3D*>(p);
  }
  return _impl_.value_;
}
inline ::pb_msg::AiVector3D* AiVectorKey::mutable_value() {
  ::pb_msg::AiVector3D* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pb_msg.AiVectorKey.Value)
  return _msg;
}
inline void AiVectorKey::set_allocated_value(::pb_msg::AiVector3D* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::pb_msg::AiVector3D*>(value);
  // @@protoc_insertion_point(field_set_allocated:pb_msg.AiVectorKey.Value)
}

// -------------------------------------------------------------------

// AiQuatKey

// double Time = 1;
inline void AiQuatKey::clear_time() {
  _impl_.time_ = 0;
}
inline double AiQuatKey::time() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiQuatKey.Time)
  return _internal_time();
}
inline void AiQuatKey::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiQuatKey.Time)
}
inline double AiQuatKey::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void AiQuatKey::_internal_set_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// .pb_msg.AiQuaternion Value = 2;
inline bool AiQuatKey::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline const ::pb_msg::AiQuaternion& AiQuatKey::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::pb_msg::AiQuaternion* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb_msg::AiQuaternion&>(::pb_msg::_AiQuaternion_default_instance_);
}
inline const ::pb_msg::AiQuaternion& AiQuatKey::value() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiQuatKey.Value)
  return _internal_value();
}
inline void AiQuatKey::unsafe_arena_set_allocated_value(::pb_msg::AiQuaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::pb_msg::AiQuaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb_msg.AiQuatKey.Value)
}
inline ::pb_msg::AiQuaternion* AiQuatKey::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pb_msg::AiQuaternion* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::pb_msg::AiQuaternion* AiQuatKey::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:pb_msg.AiQuatKey.Value)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pb_msg::AiQuaternion* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::pb_msg::AiQuaternion* AiQuatKey::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb_msg::AiQuaternion>(GetArenaForAllocation());
    _impl_.value_ = reinterpret_cast<::pb_msg::AiQuaternion*>(p);
  }
  return _impl_.value_;
}
inline ::pb_msg::AiQuaternion* AiQuatKey::mutable_value() {
  ::pb_msg::AiQuaternion* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pb_msg.AiQuatKey.Value)
  return _msg;
}
inline void AiQuatKey::set_allocated_value(::pb_msg::AiQuaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.value_ = reinterpret_cast<::pb_msg::AiQuaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:pb_msg.AiQuatKey.Value)
}

// -------------------------------------------------------------------

// AiMeshKey

// double Time = 1;
inline void AiMeshKey::clear_time() {
  _impl_.time_ = 0;
}
inline double AiMeshKey::time() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshKey.Time)
  return _internal_time();
}
inline void AiMeshKey::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiMeshKey.Time)
}
inline double AiMeshKey::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void AiMeshKey::_internal_set_time(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ = value;
}

// uint32 Value = 2;
inline void AiMeshKey::clear_value() {
  _impl_.value_ = 0u;
}
inline ::uint32_t AiMeshKey::value() const {
  // @@protoc_insertion_point(field_get:pb_msg.AiMeshKey.Value)
  return _internal_value();
}
inline void AiMeshKey::set_value(::uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:pb_msg.AiMeshKey.Value)
}
inline ::uint32_t AiMeshKey::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void AiMeshKey::_internal_set_value(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace pb_msg


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2fpb_5fmsg_2fai_5fanimation_2eproto_2epb_2eh
