// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/pb_msg/common.proto

#include "common/pb_msg/common.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
#include "google/protobuf/generated_message_tctable_impl.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace pb_msg {
        template <typename>
PROTOBUF_CONSTEXPR AiVector2D::AiVector2D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.x_)*/ 0,
      /*decltype(_impl_.y_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AiVector2DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiVector2DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiVector2DDefaultTypeInternal() {}
  union {
    AiVector2D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiVector2DDefaultTypeInternal _AiVector2D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AiVector3D::AiVector3D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.x_)*/ 0,
      /*decltype(_impl_.y_)*/ 0,
      /*decltype(_impl_.z_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AiVector3DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiVector3DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiVector3DDefaultTypeInternal() {}
  union {
    AiVector3D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiVector3DDefaultTypeInternal _AiVector3D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AiVector4D::AiVector4D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.x_)*/ 0,
      /*decltype(_impl_.y_)*/ 0,
      /*decltype(_impl_.z_)*/ 0,
      /*decltype(_impl_.w_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AiVector4DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiVector4DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiVector4DDefaultTypeInternal() {}
  union {
    AiVector4D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiVector4DDefaultTypeInternal _AiVector4D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AiColor3D::AiColor3D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.r_)*/ 0,
      /*decltype(_impl_.g_)*/ 0,
      /*decltype(_impl_.b_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AiColor3DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiColor3DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiColor3DDefaultTypeInternal() {}
  union {
    AiColor3D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiColor3DDefaultTypeInternal _AiColor3D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AiColor4D::AiColor4D(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.r_)*/ 0,
      /*decltype(_impl_.g_)*/ 0,
      /*decltype(_impl_.b_)*/ 0,
      /*decltype(_impl_.a_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AiColor4DDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiColor4DDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiColor4DDefaultTypeInternal() {}
  union {
    AiColor4D _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiColor4DDefaultTypeInternal _AiColor4D_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AiMatrix4x4::AiMatrix4x4(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.a1_)*/ 0,
      /*decltype(_impl_.a2_)*/ 0,
      /*decltype(_impl_.a3_)*/ 0,
      /*decltype(_impl_.a4_)*/ 0,
      /*decltype(_impl_.b1_)*/ 0,
      /*decltype(_impl_.b2_)*/ 0,
      /*decltype(_impl_.b3_)*/ 0,
      /*decltype(_impl_.b4_)*/ 0,
      /*decltype(_impl_.c1_)*/ 0,
      /*decltype(_impl_.c2_)*/ 0,
      /*decltype(_impl_.c3_)*/ 0,
      /*decltype(_impl_.c4_)*/ 0,
      /*decltype(_impl_.d1_)*/ 0,
      /*decltype(_impl_.d2_)*/ 0,
      /*decltype(_impl_.d3_)*/ 0,
      /*decltype(_impl_.d4_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AiMatrix4x4DefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiMatrix4x4DefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiMatrix4x4DefaultTypeInternal() {}
  union {
    AiMatrix4x4 _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiMatrix4x4DefaultTypeInternal _AiMatrix4x4_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AiQuaternion::AiQuaternion(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_.w_)*/ 0,
      /*decltype(_impl_.x_)*/ 0,
      /*decltype(_impl_.y_)*/ 0,
      /*decltype(_impl_.z_)*/ 0,
      /*decltype(_impl_._cached_size_)*/ {},
    } {}
struct AiQuaternionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiQuaternionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiQuaternionDefaultTypeInternal() {}
  union {
    AiQuaternion _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiQuaternionDefaultTypeInternal _AiQuaternion_default_instance_;
        template <typename>
PROTOBUF_CONSTEXPR AiAABB::AiAABB(::_pbi::ConstantInitialized)
    : _impl_{
      /*decltype(_impl_._has_bits_)*/ {},
      /*decltype(_impl_._cached_size_)*/ {},
      /*decltype(_impl_.min_)*/ nullptr,
      /*decltype(_impl_.max_)*/ nullptr,
    } {}
struct AiAABBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AiAABBDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AiAABBDefaultTypeInternal() {}
  union {
    AiAABB _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AiAABBDefaultTypeInternal _AiAABB_default_instance_;
}  // namespace pb_msg
static ::_pb::Metadata file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[8];
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_common_2fpb_5fmsg_2fcommon_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_common_2fpb_5fmsg_2fcommon_2eproto = nullptr;
const ::uint32_t TableStruct_common_2fpb_5fmsg_2fcommon_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector2D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector2D, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector2D, _impl_.y_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector3D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector3D, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector3D, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector3D, _impl_.z_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector4D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector4D, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector4D, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector4D, _impl_.z_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiVector4D, _impl_.w_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor3D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor3D, _impl_.r_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor3D, _impl_.g_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor3D, _impl_.b_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor4D, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor4D, _impl_.r_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor4D, _impl_.g_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor4D, _impl_.b_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiColor4D, _impl_.a_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.a1_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.a2_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.a3_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.a4_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.b1_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.b2_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.b3_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.b4_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.c1_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.c2_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.c3_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.c4_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.d1_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.d2_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.d3_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiMatrix4x4, _impl_.d4_),
    ~0u,  // no _has_bits_
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiQuaternion, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiQuaternion, _impl_.w_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiQuaternion, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiQuaternion, _impl_.y_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiQuaternion, _impl_.z_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiAABB, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiAABB, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiAABB, _impl_.min_),
    PROTOBUF_FIELD_OFFSET(::pb_msg::AiAABB, _impl_.max_),
    0,
    1,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::pb_msg::AiVector2D)},
        {10, -1, -1, sizeof(::pb_msg::AiVector3D)},
        {21, -1, -1, sizeof(::pb_msg::AiVector4D)},
        {33, -1, -1, sizeof(::pb_msg::AiColor3D)},
        {44, -1, -1, sizeof(::pb_msg::AiColor4D)},
        {56, -1, -1, sizeof(::pb_msg::AiMatrix4x4)},
        {80, -1, -1, sizeof(::pb_msg::AiQuaternion)},
        {92, 102, -1, sizeof(::pb_msg::AiAABB)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::pb_msg::_AiVector2D_default_instance_._instance,
    &::pb_msg::_AiVector3D_default_instance_._instance,
    &::pb_msg::_AiVector4D_default_instance_._instance,
    &::pb_msg::_AiColor3D_default_instance_._instance,
    &::pb_msg::_AiColor4D_default_instance_._instance,
    &::pb_msg::_AiMatrix4x4_default_instance_._instance,
    &::pb_msg::_AiQuaternion_default_instance_._instance,
    &::pb_msg::_AiAABB_default_instance_._instance,
};
const char descriptor_table_protodef_common_2fpb_5fmsg_2fcommon_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n\032common/pb_msg/common.proto\022\006pb_msg\"\"\n\n"
    "AiVector2D\022\t\n\001X\030\001 \001(\002\022\t\n\001Y\030\002 \001(\002\"-\n\nAiVe"
    "ctor3D\022\t\n\001X\030\001 \001(\002\022\t\n\001Y\030\002 \001(\002\022\t\n\001Z\030\003 \001(\002\""
    "8\n\nAiVector4D\022\t\n\001X\030\001 \001(\002\022\t\n\001Y\030\002 \001(\002\022\t\n\001Z"
    "\030\003 \001(\002\022\t\n\001W\030\004 \001(\002\",\n\tAiColor3D\022\t\n\001R\030\001 \001("
    "\002\022\t\n\001G\030\002 \001(\002\022\t\n\001B\030\003 \001(\002\"7\n\tAiColor4D\022\t\n\001"
    "R\030\001 \001(\002\022\t\n\001G\030\002 \001(\002\022\t\n\001B\030\003 \001(\002\022\t\n\001A\030\004 \001(\002"
    "\"\315\001\n\013AiMatrix4x4\022\n\n\002A1\030\001 \001(\002\022\n\n\002a2\030\002 \001(\002"
    "\022\n\n\002a3\030\003 \001(\002\022\n\n\002a4\030\004 \001(\002\022\n\n\002b1\030\005 \001(\002\022\n\n\002"
    "b2\030\006 \001(\002\022\n\n\002b3\030\007 \001(\002\022\n\n\002b4\030\010 \001(\002\022\n\n\002c1\030\t"
    " \001(\002\022\n\n\002c2\030\n \001(\002\022\n\n\002c3\030\013 \001(\002\022\n\n\002c4\030\014 \001(\002"
    "\022\n\n\002d1\030\r \001(\002\022\n\n\002d2\030\016 \001(\002\022\n\n\002d3\030\017 \001(\002\022\n\n\002"
    "d4\030\020 \001(\002\":\n\014AiQuaternion\022\t\n\001W\030\001 \001(\001\022\t\n\001X"
    "\030\002 \001(\001\022\t\n\001Y\030\003 \001(\001\022\t\n\001Z\030\004 \001(\001\"J\n\006AiAABB\022\037"
    "\n\003Min\030\001 \001(\0132\022.pb_msg.AiVector3D\022\037\n\003Max\030\002"
    " \001(\0132\022.pb_msg.AiVector3DB\017Z\rcommon/pb_ms"
    "gb\006proto3"
};
static ::absl::once_flag descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto = {
    false,
    false,
    649,
    descriptor_table_protodef_common_2fpb_5fmsg_2fcommon_2eproto,
    "common/pb_msg/common.proto",
    &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
    nullptr,
    0,
    8,
    schemas,
    file_default_instances,
    TableStruct_common_2fpb_5fmsg_2fcommon_2eproto::offsets,
    file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto,
    file_level_enum_descriptors_common_2fpb_5fmsg_2fcommon_2eproto,
    file_level_service_descriptors_common_2fpb_5fmsg_2fcommon_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter() {
  return &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_common_2fpb_5fmsg_2fcommon_2eproto(&descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto);
namespace pb_msg {
// ===================================================================

class AiVector2D::_Internal {
 public:
};

AiVector2D::AiVector2D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiVector2D)
}
AiVector2D::AiVector2D(const AiVector2D& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb_msg.AiVector2D)
}
inline void AiVector2D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0},
      decltype(_impl_.y_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AiVector2D::~AiVector2D() {
  // @@protoc_insertion_point(destructor:pb_msg.AiVector2D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiVector2D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AiVector2D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiVector2D::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiVector2D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiVector2D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> AiVector2D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AiVector2D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float Y = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector2D, _impl_.y_)}},
    // float X = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector2D, _impl_.x_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float X = 1;
    {PROTOBUF_FIELD_OFFSET(AiVector2D, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float Y = 2;
    {PROTOBUF_FIELD_OFFSET(AiVector2D, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AiVector2D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiVector2D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float X = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float Y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiVector2D)
  return target;
}

::size_t AiVector2D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiVector2D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float X = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float Y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiVector2D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiVector2D::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiVector2D::GetClassData() const { return &_class_data_; }


void AiVector2D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiVector2D*>(&to_msg);
  auto& from = static_cast<const AiVector2D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiVector2D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiVector2D::CopyFrom(const AiVector2D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiVector2D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiVector2D::IsInitialized() const {
  return true;
}

void AiVector2D::InternalSwap(AiVector2D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiVector2D, _impl_.y_)
      + sizeof(AiVector2D::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(AiVector2D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata AiVector2D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[0]);
}
// ===================================================================

class AiVector3D::_Internal {
 public:
};

AiVector3D::AiVector3D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiVector3D)
}
AiVector3D::AiVector3D(const AiVector3D& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb_msg.AiVector3D)
}
inline void AiVector3D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0},
      decltype(_impl_.y_){0},
      decltype(_impl_.z_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AiVector3D::~AiVector3D() {
  // @@protoc_insertion_point(destructor:pb_msg.AiVector3D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiVector3D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AiVector3D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiVector3D::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiVector3D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiVector3D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> AiVector3D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AiVector3D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float X = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.x_)}},
    // float Y = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.y_)}},
    // float Z = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float X = 1;
    {PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float Y = 2;
    {PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float Z = 3;
    {PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AiVector3D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiVector3D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float X = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float Y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float Z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiVector3D)
  return target;
}

::size_t AiVector3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiVector3D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float X = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float Y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float Z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiVector3D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiVector3D::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiVector3D::GetClassData() const { return &_class_data_; }


void AiVector3D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiVector3D*>(&to_msg);
  auto& from = static_cast<const AiVector3D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiVector3D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiVector3D::CopyFrom(const AiVector3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiVector3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiVector3D::IsInitialized() const {
  return true;
}

void AiVector3D::InternalSwap(AiVector3D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.z_)
      + sizeof(AiVector3D::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(AiVector3D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata AiVector3D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[1]);
}
// ===================================================================

class AiVector4D::_Internal {
 public:
};

AiVector4D::AiVector4D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiVector4D)
}
AiVector4D::AiVector4D(const AiVector4D& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb_msg.AiVector4D)
}
inline void AiVector4D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0},
      decltype(_impl_.y_){0},
      decltype(_impl_.z_){0},
      decltype(_impl_.w_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AiVector4D::~AiVector4D() {
  // @@protoc_insertion_point(destructor:pb_msg.AiVector4D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiVector4D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AiVector4D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiVector4D::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiVector4D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.w_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.w_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiVector4D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> AiVector4D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AiVector4D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float W = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.w_)}},
    // float X = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.x_)}},
    // float Y = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.y_)}},
    // float Z = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.z_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float X = 1;
    {PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float Y = 2;
    {PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float Z = 3;
    {PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float W = 4;
    {PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.w_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AiVector4D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiVector4D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float X = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_x(), target);
  }

  // float Y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_y(), target);
  }

  // float Z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_z(), target);
  }

  // float W = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_w(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiVector4D)
  return target;
}

::size_t AiVector4D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiVector4D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float X = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 5;
  }

  // float Y = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 5;
  }

  // float Z = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 5;
  }

  // float W = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiVector4D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiVector4D::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiVector4D::GetClassData() const { return &_class_data_; }


void AiVector4D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiVector4D*>(&to_msg);
  auto& from = static_cast<const AiVector4D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiVector4D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  ::uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  ::uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  ::uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  ::uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiVector4D::CopyFrom(const AiVector4D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiVector4D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiVector4D::IsInitialized() const {
  return true;
}

void AiVector4D::InternalSwap(AiVector4D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.w_)
      + sizeof(AiVector4D::_impl_.w_)
      - PROTOBUF_FIELD_OFFSET(AiVector4D, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata AiVector4D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[2]);
}
// ===================================================================

class AiColor3D::_Internal {
 public:
};

AiColor3D::AiColor3D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiColor3D)
}
AiColor3D::AiColor3D(const AiColor3D& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb_msg.AiColor3D)
}
inline void AiColor3D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.r_){0},
      decltype(_impl_.g_){0},
      decltype(_impl_.b_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AiColor3D::~AiColor3D() {
  // @@protoc_insertion_point(destructor:pb_msg.AiColor3D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiColor3D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AiColor3D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiColor3D::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiColor3D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.r_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.b_) -
      reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.b_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiColor3D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> AiColor3D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AiColor3D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float R = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.r_)}},
    // float G = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.g_)}},
    // float B = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.b_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float R = 1;
    {PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.r_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float G = 2;
    {PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.g_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float B = 3;
    {PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.b_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AiColor3D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiColor3D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float R = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_r = this->_internal_r();
  ::uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_r(), target);
  }

  // float G = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_g = this->_internal_g();
  ::uint32_t raw_g;
  memcpy(&raw_g, &tmp_g, sizeof(tmp_g));
  if (raw_g != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_g(), target);
  }

  // float B = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_b(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiColor3D)
  return target;
}

::size_t AiColor3D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiColor3D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float R = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_r = this->_internal_r();
  ::uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    total_size += 5;
  }

  // float G = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_g = this->_internal_g();
  ::uint32_t raw_g;
  memcpy(&raw_g, &tmp_g, sizeof(tmp_g));
  if (raw_g != 0) {
    total_size += 5;
  }

  // float B = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiColor3D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiColor3D::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiColor3D::GetClassData() const { return &_class_data_; }


void AiColor3D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiColor3D*>(&to_msg);
  auto& from = static_cast<const AiColor3D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiColor3D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_r = from._internal_r();
  ::uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_g = from._internal_g();
  ::uint32_t raw_g;
  memcpy(&raw_g, &tmp_g, sizeof(tmp_g));
  if (raw_g != 0) {
    _this->_internal_set_g(from._internal_g());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = from._internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    _this->_internal_set_b(from._internal_b());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiColor3D::CopyFrom(const AiColor3D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiColor3D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiColor3D::IsInitialized() const {
  return true;
}

void AiColor3D::InternalSwap(AiColor3D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.b_)
      + sizeof(AiColor3D::_impl_.b_)
      - PROTOBUF_FIELD_OFFSET(AiColor3D, _impl_.r_)>(
          reinterpret_cast<char*>(&_impl_.r_),
          reinterpret_cast<char*>(&other->_impl_.r_));
}

::google::protobuf::Metadata AiColor3D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[3]);
}
// ===================================================================

class AiColor4D::_Internal {
 public:
};

AiColor4D::AiColor4D(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiColor4D)
}
AiColor4D::AiColor4D(const AiColor4D& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb_msg.AiColor4D)
}
inline void AiColor4D::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.r_){0},
      decltype(_impl_.g_){0},
      decltype(_impl_.b_){0},
      decltype(_impl_.a_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AiColor4D::~AiColor4D() {
  // @@protoc_insertion_point(destructor:pb_msg.AiColor4D)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiColor4D::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AiColor4D::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiColor4D::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiColor4D)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.r_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.a_) -
      reinterpret_cast<char*>(&_impl_.r_)) + sizeof(_impl_.a_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiColor4D::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> AiColor4D::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AiColor4D_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float A = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.a_)}},
    // float R = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.r_)}},
    // float G = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.g_)}},
    // float B = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.b_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float R = 1;
    {PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.r_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float G = 2;
    {PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.g_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float B = 3;
    {PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.b_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float A = 4;
    {PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.a_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AiColor4D::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiColor4D)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float R = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_r = this->_internal_r();
  ::uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_r(), target);
  }

  // float G = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_g = this->_internal_g();
  ::uint32_t raw_g;
  memcpy(&raw_g, &tmp_g, sizeof(tmp_g));
  if (raw_g != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_g(), target);
  }

  // float B = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_b(), target);
  }

  // float A = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a = this->_internal_a();
  ::uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_a(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiColor4D)
  return target;
}

::size_t AiColor4D::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiColor4D)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float R = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_r = this->_internal_r();
  ::uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    total_size += 5;
  }

  // float G = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_g = this->_internal_g();
  ::uint32_t raw_g;
  memcpy(&raw_g, &tmp_g, sizeof(tmp_g));
  if (raw_g != 0) {
    total_size += 5;
  }

  // float B = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = this->_internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    total_size += 5;
  }

  // float A = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a = this->_internal_a();
  ::uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    total_size += 5;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiColor4D::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiColor4D::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiColor4D::GetClassData() const { return &_class_data_; }


void AiColor4D::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiColor4D*>(&to_msg);
  auto& from = static_cast<const AiColor4D&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiColor4D)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_r = from._internal_r();
  ::uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_g = from._internal_g();
  ::uint32_t raw_g;
  memcpy(&raw_g, &tmp_g, sizeof(tmp_g));
  if (raw_g != 0) {
    _this->_internal_set_g(from._internal_g());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b = from._internal_b();
  ::uint32_t raw_b;
  memcpy(&raw_b, &tmp_b, sizeof(tmp_b));
  if (raw_b != 0) {
    _this->_internal_set_b(from._internal_b());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a = from._internal_a();
  ::uint32_t raw_a;
  memcpy(&raw_a, &tmp_a, sizeof(tmp_a));
  if (raw_a != 0) {
    _this->_internal_set_a(from._internal_a());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiColor4D::CopyFrom(const AiColor4D& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiColor4D)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiColor4D::IsInitialized() const {
  return true;
}

void AiColor4D::InternalSwap(AiColor4D* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.a_)
      + sizeof(AiColor4D::_impl_.a_)
      - PROTOBUF_FIELD_OFFSET(AiColor4D, _impl_.r_)>(
          reinterpret_cast<char*>(&_impl_.r_),
          reinterpret_cast<char*>(&other->_impl_.r_));
}

::google::protobuf::Metadata AiColor4D::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[4]);
}
// ===================================================================

class AiMatrix4x4::_Internal {
 public:
};

AiMatrix4x4::AiMatrix4x4(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiMatrix4x4)
}
AiMatrix4x4::AiMatrix4x4(const AiMatrix4x4& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb_msg.AiMatrix4x4)
}
inline void AiMatrix4x4::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.a1_){0},
      decltype(_impl_.a2_){0},
      decltype(_impl_.a3_){0},
      decltype(_impl_.a4_){0},
      decltype(_impl_.b1_){0},
      decltype(_impl_.b2_){0},
      decltype(_impl_.b3_){0},
      decltype(_impl_.b4_){0},
      decltype(_impl_.c1_){0},
      decltype(_impl_.c2_){0},
      decltype(_impl_.c3_){0},
      decltype(_impl_.c4_){0},
      decltype(_impl_.d1_){0},
      decltype(_impl_.d2_){0},
      decltype(_impl_.d3_){0},
      decltype(_impl_.d4_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AiMatrix4x4::~AiMatrix4x4() {
  // @@protoc_insertion_point(destructor:pb_msg.AiMatrix4x4)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiMatrix4x4::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AiMatrix4x4::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiMatrix4x4::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiMatrix4x4)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.a1_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.d4_) -
      reinterpret_cast<char*>(&_impl_.a1_)) + sizeof(_impl_.d4_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiMatrix4x4::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 16, 0, 0, 2> AiMatrix4x4::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    16, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294901760,  // skipmap
    offsetof(decltype(_table_), field_entries),
    16,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AiMatrix4x4_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // float d4 = 16;
    {::_pbi::TcParser::FastF32S2,
     {389, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d4_)}},
    // float A1 = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a1_)}},
    // float a2 = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a2_)}},
    // float a3 = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a3_)}},
    // float a4 = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a4_)}},
    // float b1 = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b1_)}},
    // float b2 = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b2_)}},
    // float b3 = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b3_)}},
    // float b4 = 8;
    {::_pbi::TcParser::FastF32S1,
     {69, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b4_)}},
    // float c1 = 9;
    {::_pbi::TcParser::FastF32S1,
     {77, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c1_)}},
    // float c2 = 10;
    {::_pbi::TcParser::FastF32S1,
     {85, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c2_)}},
    // float c3 = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c3_)}},
    // float c4 = 12;
    {::_pbi::TcParser::FastF32S1,
     {101, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c4_)}},
    // float d1 = 13;
    {::_pbi::TcParser::FastF32S1,
     {109, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d1_)}},
    // float d2 = 14;
    {::_pbi::TcParser::FastF32S1,
     {117, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d2_)}},
    // float d3 = 15;
    {::_pbi::TcParser::FastF32S1,
     {125, 63, 0, PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d3_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float A1 = 1;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a1_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float a2 = 2;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float a3 = 3;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a3_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float a4 = 4;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a4_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float b1 = 5;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b1_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float b2 = 6;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float b3 = 7;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b3_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float b4 = 8;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.b4_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float c1 = 9;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c1_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float c2 = 10;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float c3 = 11;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c3_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float c4 = 12;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.c4_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float d1 = 13;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d1_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float d2 = 14;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d2_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float d3 = 15;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d3_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
    // float d4 = 16;
    {PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d4_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AiMatrix4x4::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiMatrix4x4)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // float A1 = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a1 = this->_internal_a1();
  ::uint32_t raw_a1;
  memcpy(&raw_a1, &tmp_a1, sizeof(tmp_a1));
  if (raw_a1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        1, this->_internal_a1(), target);
  }

  // float a2 = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a2 = this->_internal_a2();
  ::uint32_t raw_a2;
  memcpy(&raw_a2, &tmp_a2, sizeof(tmp_a2));
  if (raw_a2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        2, this->_internal_a2(), target);
  }

  // float a3 = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a3 = this->_internal_a3();
  ::uint32_t raw_a3;
  memcpy(&raw_a3, &tmp_a3, sizeof(tmp_a3));
  if (raw_a3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        3, this->_internal_a3(), target);
  }

  // float a4 = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a4 = this->_internal_a4();
  ::uint32_t raw_a4;
  memcpy(&raw_a4, &tmp_a4, sizeof(tmp_a4));
  if (raw_a4 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        4, this->_internal_a4(), target);
  }

  // float b1 = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b1 = this->_internal_b1();
  ::uint32_t raw_b1;
  memcpy(&raw_b1, &tmp_b1, sizeof(tmp_b1));
  if (raw_b1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_b1(), target);
  }

  // float b2 = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b2 = this->_internal_b2();
  ::uint32_t raw_b2;
  memcpy(&raw_b2, &tmp_b2, sizeof(tmp_b2));
  if (raw_b2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        6, this->_internal_b2(), target);
  }

  // float b3 = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b3 = this->_internal_b3();
  ::uint32_t raw_b3;
  memcpy(&raw_b3, &tmp_b3, sizeof(tmp_b3));
  if (raw_b3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        7, this->_internal_b3(), target);
  }

  // float b4 = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b4 = this->_internal_b4();
  ::uint32_t raw_b4;
  memcpy(&raw_b4, &tmp_b4, sizeof(tmp_b4));
  if (raw_b4 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        8, this->_internal_b4(), target);
  }

  // float c1 = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c1 = this->_internal_c1();
  ::uint32_t raw_c1;
  memcpy(&raw_c1, &tmp_c1, sizeof(tmp_c1));
  if (raw_c1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        9, this->_internal_c1(), target);
  }

  // float c2 = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c2 = this->_internal_c2();
  ::uint32_t raw_c2;
  memcpy(&raw_c2, &tmp_c2, sizeof(tmp_c2));
  if (raw_c2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        10, this->_internal_c2(), target);
  }

  // float c3 = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c3 = this->_internal_c3();
  ::uint32_t raw_c3;
  memcpy(&raw_c3, &tmp_c3, sizeof(tmp_c3));
  if (raw_c3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        11, this->_internal_c3(), target);
  }

  // float c4 = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c4 = this->_internal_c4();
  ::uint32_t raw_c4;
  memcpy(&raw_c4, &tmp_c4, sizeof(tmp_c4));
  if (raw_c4 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        12, this->_internal_c4(), target);
  }

  // float d1 = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d1 = this->_internal_d1();
  ::uint32_t raw_d1;
  memcpy(&raw_d1, &tmp_d1, sizeof(tmp_d1));
  if (raw_d1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        13, this->_internal_d1(), target);
  }

  // float d2 = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d2 = this->_internal_d2();
  ::uint32_t raw_d2;
  memcpy(&raw_d2, &tmp_d2, sizeof(tmp_d2));
  if (raw_d2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        14, this->_internal_d2(), target);
  }

  // float d3 = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d3 = this->_internal_d3();
  ::uint32_t raw_d3;
  memcpy(&raw_d3, &tmp_d3, sizeof(tmp_d3));
  if (raw_d3 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        15, this->_internal_d3(), target);
  }

  // float d4 = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d4 = this->_internal_d4();
  ::uint32_t raw_d4;
  memcpy(&raw_d4, &tmp_d4, sizeof(tmp_d4));
  if (raw_d4 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        16, this->_internal_d4(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiMatrix4x4)
  return target;
}

::size_t AiMatrix4x4::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiMatrix4x4)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float A1 = 1;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a1 = this->_internal_a1();
  ::uint32_t raw_a1;
  memcpy(&raw_a1, &tmp_a1, sizeof(tmp_a1));
  if (raw_a1 != 0) {
    total_size += 5;
  }

  // float a2 = 2;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a2 = this->_internal_a2();
  ::uint32_t raw_a2;
  memcpy(&raw_a2, &tmp_a2, sizeof(tmp_a2));
  if (raw_a2 != 0) {
    total_size += 5;
  }

  // float a3 = 3;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a3 = this->_internal_a3();
  ::uint32_t raw_a3;
  memcpy(&raw_a3, &tmp_a3, sizeof(tmp_a3));
  if (raw_a3 != 0) {
    total_size += 5;
  }

  // float a4 = 4;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a4 = this->_internal_a4();
  ::uint32_t raw_a4;
  memcpy(&raw_a4, &tmp_a4, sizeof(tmp_a4));
  if (raw_a4 != 0) {
    total_size += 5;
  }

  // float b1 = 5;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b1 = this->_internal_b1();
  ::uint32_t raw_b1;
  memcpy(&raw_b1, &tmp_b1, sizeof(tmp_b1));
  if (raw_b1 != 0) {
    total_size += 5;
  }

  // float b2 = 6;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b2 = this->_internal_b2();
  ::uint32_t raw_b2;
  memcpy(&raw_b2, &tmp_b2, sizeof(tmp_b2));
  if (raw_b2 != 0) {
    total_size += 5;
  }

  // float b3 = 7;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b3 = this->_internal_b3();
  ::uint32_t raw_b3;
  memcpy(&raw_b3, &tmp_b3, sizeof(tmp_b3));
  if (raw_b3 != 0) {
    total_size += 5;
  }

  // float b4 = 8;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b4 = this->_internal_b4();
  ::uint32_t raw_b4;
  memcpy(&raw_b4, &tmp_b4, sizeof(tmp_b4));
  if (raw_b4 != 0) {
    total_size += 5;
  }

  // float c1 = 9;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c1 = this->_internal_c1();
  ::uint32_t raw_c1;
  memcpy(&raw_c1, &tmp_c1, sizeof(tmp_c1));
  if (raw_c1 != 0) {
    total_size += 5;
  }

  // float c2 = 10;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c2 = this->_internal_c2();
  ::uint32_t raw_c2;
  memcpy(&raw_c2, &tmp_c2, sizeof(tmp_c2));
  if (raw_c2 != 0) {
    total_size += 5;
  }

  // float c3 = 11;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c3 = this->_internal_c3();
  ::uint32_t raw_c3;
  memcpy(&raw_c3, &tmp_c3, sizeof(tmp_c3));
  if (raw_c3 != 0) {
    total_size += 5;
  }

  // float c4 = 12;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c4 = this->_internal_c4();
  ::uint32_t raw_c4;
  memcpy(&raw_c4, &tmp_c4, sizeof(tmp_c4));
  if (raw_c4 != 0) {
    total_size += 5;
  }

  // float d1 = 13;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d1 = this->_internal_d1();
  ::uint32_t raw_d1;
  memcpy(&raw_d1, &tmp_d1, sizeof(tmp_d1));
  if (raw_d1 != 0) {
    total_size += 5;
  }

  // float d2 = 14;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d2 = this->_internal_d2();
  ::uint32_t raw_d2;
  memcpy(&raw_d2, &tmp_d2, sizeof(tmp_d2));
  if (raw_d2 != 0) {
    total_size += 5;
  }

  // float d3 = 15;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d3 = this->_internal_d3();
  ::uint32_t raw_d3;
  memcpy(&raw_d3, &tmp_d3, sizeof(tmp_d3));
  if (raw_d3 != 0) {
    total_size += 5;
  }

  // float d4 = 16;
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d4 = this->_internal_d4();
  ::uint32_t raw_d4;
  memcpy(&raw_d4, &tmp_d4, sizeof(tmp_d4));
  if (raw_d4 != 0) {
    total_size += 6;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiMatrix4x4::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiMatrix4x4::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiMatrix4x4::GetClassData() const { return &_class_data_; }


void AiMatrix4x4::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiMatrix4x4*>(&to_msg);
  auto& from = static_cast<const AiMatrix4x4&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiMatrix4x4)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a1 = from._internal_a1();
  ::uint32_t raw_a1;
  memcpy(&raw_a1, &tmp_a1, sizeof(tmp_a1));
  if (raw_a1 != 0) {
    _this->_internal_set_a1(from._internal_a1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a2 = from._internal_a2();
  ::uint32_t raw_a2;
  memcpy(&raw_a2, &tmp_a2, sizeof(tmp_a2));
  if (raw_a2 != 0) {
    _this->_internal_set_a2(from._internal_a2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a3 = from._internal_a3();
  ::uint32_t raw_a3;
  memcpy(&raw_a3, &tmp_a3, sizeof(tmp_a3));
  if (raw_a3 != 0) {
    _this->_internal_set_a3(from._internal_a3());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_a4 = from._internal_a4();
  ::uint32_t raw_a4;
  memcpy(&raw_a4, &tmp_a4, sizeof(tmp_a4));
  if (raw_a4 != 0) {
    _this->_internal_set_a4(from._internal_a4());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b1 = from._internal_b1();
  ::uint32_t raw_b1;
  memcpy(&raw_b1, &tmp_b1, sizeof(tmp_b1));
  if (raw_b1 != 0) {
    _this->_internal_set_b1(from._internal_b1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b2 = from._internal_b2();
  ::uint32_t raw_b2;
  memcpy(&raw_b2, &tmp_b2, sizeof(tmp_b2));
  if (raw_b2 != 0) {
    _this->_internal_set_b2(from._internal_b2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b3 = from._internal_b3();
  ::uint32_t raw_b3;
  memcpy(&raw_b3, &tmp_b3, sizeof(tmp_b3));
  if (raw_b3 != 0) {
    _this->_internal_set_b3(from._internal_b3());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_b4 = from._internal_b4();
  ::uint32_t raw_b4;
  memcpy(&raw_b4, &tmp_b4, sizeof(tmp_b4));
  if (raw_b4 != 0) {
    _this->_internal_set_b4(from._internal_b4());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c1 = from._internal_c1();
  ::uint32_t raw_c1;
  memcpy(&raw_c1, &tmp_c1, sizeof(tmp_c1));
  if (raw_c1 != 0) {
    _this->_internal_set_c1(from._internal_c1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c2 = from._internal_c2();
  ::uint32_t raw_c2;
  memcpy(&raw_c2, &tmp_c2, sizeof(tmp_c2));
  if (raw_c2 != 0) {
    _this->_internal_set_c2(from._internal_c2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c3 = from._internal_c3();
  ::uint32_t raw_c3;
  memcpy(&raw_c3, &tmp_c3, sizeof(tmp_c3));
  if (raw_c3 != 0) {
    _this->_internal_set_c3(from._internal_c3());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_c4 = from._internal_c4();
  ::uint32_t raw_c4;
  memcpy(&raw_c4, &tmp_c4, sizeof(tmp_c4));
  if (raw_c4 != 0) {
    _this->_internal_set_c4(from._internal_c4());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d1 = from._internal_d1();
  ::uint32_t raw_d1;
  memcpy(&raw_d1, &tmp_d1, sizeof(tmp_d1));
  if (raw_d1 != 0) {
    _this->_internal_set_d1(from._internal_d1());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d2 = from._internal_d2();
  ::uint32_t raw_d2;
  memcpy(&raw_d2, &tmp_d2, sizeof(tmp_d2));
  if (raw_d2 != 0) {
    _this->_internal_set_d2(from._internal_d2());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d3 = from._internal_d3();
  ::uint32_t raw_d3;
  memcpy(&raw_d3, &tmp_d3, sizeof(tmp_d3));
  if (raw_d3 != 0) {
    _this->_internal_set_d3(from._internal_d3());
  }
  static_assert(sizeof(::uint32_t) == sizeof(float),
                "Code assumes ::uint32_t and float are the same size.");
  float tmp_d4 = from._internal_d4();
  ::uint32_t raw_d4;
  memcpy(&raw_d4, &tmp_d4, sizeof(tmp_d4));
  if (raw_d4 != 0) {
    _this->_internal_set_d4(from._internal_d4());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiMatrix4x4::CopyFrom(const AiMatrix4x4& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiMatrix4x4)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiMatrix4x4::IsInitialized() const {
  return true;
}

void AiMatrix4x4::InternalSwap(AiMatrix4x4* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.d4_)
      + sizeof(AiMatrix4x4::_impl_.d4_)
      - PROTOBUF_FIELD_OFFSET(AiMatrix4x4, _impl_.a1_)>(
          reinterpret_cast<char*>(&_impl_.a1_),
          reinterpret_cast<char*>(&other->_impl_.a1_));
}

::google::protobuf::Metadata AiMatrix4x4::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[5]);
}
// ===================================================================

class AiQuaternion::_Internal {
 public:
};

AiQuaternion::AiQuaternion(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiQuaternion)
}
AiQuaternion::AiQuaternion(const AiQuaternion& from)
    : ::google::protobuf::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pb_msg.AiQuaternion)
}
inline void AiQuaternion::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_.w_){0},
      decltype(_impl_.x_){0},
      decltype(_impl_.y_){0},
      decltype(_impl_.z_){0},
      /*decltype(_impl_._cached_size_)*/ {},
  };
}
AiQuaternion::~AiQuaternion() {
  // @@protoc_insertion_point(destructor:pb_msg.AiQuaternion)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiQuaternion::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}
void AiQuaternion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiQuaternion::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiQuaternion)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.w_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.w_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiQuaternion::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 0, 2> AiQuaternion::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    &_AiQuaternion_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // double Z = 4;
    {::_pbi::TcParser::FastF64S1,
     {33, 63, 0, PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.z_)}},
    // double W = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.w_)}},
    // double X = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.x_)}},
    // double Y = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.y_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double W = 1;
    {PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.w_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double X = 2;
    {PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double Y = 3;
    {PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double Z = 4;
    {PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.z_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

::uint8_t* AiQuaternion::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiQuaternion)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // double W = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  ::uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        1, this->_internal_w(), target);
  }

  // double X = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_x(), target);
  }

  // double Y = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_y(), target);
  }

  // double Z = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiQuaternion)
  return target;
}

::size_t AiQuaternion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiQuaternion)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // double W = 1;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_w = this->_internal_w();
  ::uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 9;
  }

  // double X = 2;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = this->_internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 9;
  }

  // double Y = 3;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = this->_internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 9;
  }

  // double Z = 4;
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = this->_internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 9;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiQuaternion::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiQuaternion::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiQuaternion::GetClassData() const { return &_class_data_; }


void AiQuaternion::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiQuaternion*>(&to_msg);
  auto& from = static_cast<const AiQuaternion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiQuaternion)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_w = from._internal_w();
  ::uint64_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_x = from._internal_x();
  ::uint64_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_y = from._internal_y();
  ::uint64_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(::uint64_t) == sizeof(double),
                "Code assumes ::uint64_t and double are the same size.");
  double tmp_z = from._internal_z();
  ::uint64_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiQuaternion::CopyFrom(const AiQuaternion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiQuaternion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiQuaternion::IsInitialized() const {
  return true;
}

void AiQuaternion::InternalSwap(AiQuaternion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.z_)
      + sizeof(AiQuaternion::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(AiQuaternion, _impl_.w_)>(
          reinterpret_cast<char*>(&_impl_.w_),
          reinterpret_cast<char*>(&other->_impl_.w_));
}

::google::protobuf::Metadata AiQuaternion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[6]);
}
// ===================================================================

class AiAABB::_Internal {
 public:
  using HasBits = decltype(std::declval<AiAABB>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(AiAABB, _impl_._has_bits_);
  static const ::pb_msg::AiVector3D& min(const AiAABB* msg);
  static void set_has_min(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pb_msg::AiVector3D& max(const AiAABB* msg);
  static void set_has_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pb_msg::AiVector3D& AiAABB::_Internal::min(const AiAABB* msg) {
  return *msg->_impl_.min_;
}
const ::pb_msg::AiVector3D& AiAABB::_Internal::max(const AiAABB* msg) {
  return *msg->_impl_.max_;
}
AiAABB::AiAABB(::google::protobuf::Arena* arena)
    : ::google::protobuf::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:pb_msg.AiAABB)
}
AiAABB::AiAABB(const AiAABB& from) : ::google::protobuf::Message() {
  AiAABB* const _this = this;
  (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.min_){nullptr},
      decltype(_impl_.max_){nullptr},
  };
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.min_ = new ::pb_msg::AiVector3D(*from._impl_.min_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.max_ = new ::pb_msg::AiVector3D(*from._impl_.max_);
  }

  // @@protoc_insertion_point(copy_constructor:pb_msg.AiAABB)
}
inline void AiAABB::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){},
      /*decltype(_impl_._cached_size_)*/ {},
      decltype(_impl_.min_){nullptr},
      decltype(_impl_.max_){nullptr},
  };
}
AiAABB::~AiAABB() {
  // @@protoc_insertion_point(destructor:pb_msg.AiAABB)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AiAABB::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.min_;
  if (this != internal_default_instance()) delete _impl_.max_;
}
void AiAABB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

PROTOBUF_NOINLINE void AiAABB::Clear() {
// @@protoc_insertion_point(message_clear_start:pb_msg.AiAABB)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.min_ != nullptr);
      _impl_.min_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.max_ != nullptr);
      _impl_.max_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

const char* AiAABB::_InternalParse(
    const char* ptr, ::_pbi::ParseContext* ctx) {
  ptr = ::_pbi::TcParser::ParseLoop(this, ptr, ctx, &_table_.header);
  return ptr;
}


PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> AiAABB::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AiAABB, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    &_AiAABB_default_instance_._instance,
    ::_pbi::TcParser::GenericFallback,  // fallback
  }, {{
    // .pb_msg.AiVector3D Max = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(AiAABB, _impl_.max_)}},
    // .pb_msg.AiVector3D Min = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AiAABB, _impl_.min_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .pb_msg.AiVector3D Min = 1;
    {PROTOBUF_FIELD_OFFSET(AiAABB, _impl_.min_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .pb_msg.AiVector3D Max = 2;
    {PROTOBUF_FIELD_OFFSET(AiAABB, _impl_.max_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::pb_msg::AiVector3D>()},
    {::_pbi::TcParser::GetTable<::pb_msg::AiVector3D>()},
  }}, {{
  }},
};

::uint8_t* AiAABB::_InternalSerialize(
    ::uint8_t* target,
    ::google::protobuf::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pb_msg.AiAABB)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // .pb_msg.AiVector3D Min = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::min(this),
        _Internal::min(this).GetCachedSize(), target, stream);
  }

  // .pb_msg.AiVector3D Max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::max(this),
        _Internal::max(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pb_msg.AiAABB)
  return target;
}

::size_t AiAABB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pb_msg.AiAABB)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // .pb_msg.AiVector3D Min = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.min_);
    }

    // .pb_msg.AiVector3D Max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *_impl_.max_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::google::protobuf::Message::ClassData AiAABB::_class_data_ = {
    ::google::protobuf::Message::CopyWithSourceCheck,
    AiAABB::MergeImpl
};
const ::google::protobuf::Message::ClassData*AiAABB::GetClassData() const { return &_class_data_; }


void AiAABB::MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg) {
  auto* const _this = static_cast<AiAABB*>(&to_msg);
  auto& from = static_cast<const AiAABB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pb_msg.AiAABB)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_min()->::pb_msg::AiVector3D::MergeFrom(
          from._internal_min());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_max()->::pb_msg::AiVector3D::MergeFrom(
          from._internal_max());
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AiAABB::CopyFrom(const AiAABB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pb_msg.AiAABB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

PROTOBUF_NOINLINE bool AiAABB::IsInitialized() const {
  return true;
}

void AiAABB::InternalSwap(AiAABB* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AiAABB, _impl_.max_)
      + sizeof(AiAABB::_impl_.max_)
      - PROTOBUF_FIELD_OFFSET(AiAABB, _impl_.min_)>(
          reinterpret_cast<char*>(&_impl_.min_),
          reinterpret_cast<char*>(&other->_impl_.min_));
}

::google::protobuf::Metadata AiAABB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_getter, &descriptor_table_common_2fpb_5fmsg_2fcommon_2eproto_once,
      file_level_metadata_common_2fpb_5fmsg_2fcommon_2eproto[7]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace pb_msg
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
